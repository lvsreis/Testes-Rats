// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.4.0,
// (C) 2004-2014 Robert Grimm,
// on s√°bado, 31 de outubro de 2020 at 20:44:59.
// Edit at your own risk.
// ===========================================================================

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>func</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.4.0, (C) 2004-2014 Robert Grimm.
 */
public final class func extends ParserBase {

  // =========================================================================

  /** Memoization table column. */
  static final class funcColumn extends Column {
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public func(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public func(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new funcColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal func.prog.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pprog(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;
        if (('a' <= yyC) && (yyC <= 'z')) {

          yyRepetition1 = yyIndex;
          continue;
        }
      }
      break;
    }

    while (true) {

      yyC = character(yyRepetition1);
      if (' ' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        continue;
      }
      break;
    }

    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;
        if (('a' <= yyC) && (yyC <= 'z')) {

          yyRepetition1 = yyIndex;
          continue;
        }
      }
      break;
    }

    yyBase = yyRepetition1;
    yyC    = character(yyBase);
    if (' ' == yyC) {
      yyIndex = yyRepetition1 + 1;

      yyBase = yyIndex;
      yyC    = character(yyBase);
      if ('{' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if ('\n' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyRepetition1 = yyIndex;
            continue;
          }
          break;
        }

        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if (('a' <= yyC) && (yyC <= 'z')) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if (';' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if ('\n' == yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
            break;
          }

          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;
              if (('a' <= yyC) && (yyC <= 'z')) {

                yyRepetition1 = yyIndex;
                continue;
              }
            }
            break;
          }

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (';' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyRepetition1 = yyIndex;
            while (true) {

              yyC = character(yyRepetition1);
              if ('\n' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyRepetition1 = yyIndex;
                continue;
              }
              break;
            }

            yyBase = yyRepetition1;
            yyC    = character(yyBase);
            if ('}' == yyC) {
              yyIndex = yyRepetition1 + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("'}' expected", yyBase);
            }
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'{' expected", yyBase);
      }
    } else {
      yyError = yyError.select("' ' expected", yyBase);
    }

    // Done.
    yyError = yyError.select("prog expected", yyStart);
    return yyError;
  }

}
